## **프로세스 관련 용어**

- **Process (프로세스):** 실행 중인 프로그램으로, 운영 체제에서 작업의 기본 단위입니다. 프로세스는 CPU 시간, 메모리, 파일, I/O 장치 등 특정 자원을 필요로 합니다.

- **Memory Layout of a Process (프로세스의 메모리 레이아웃):** 프로세스의 메모리는 여러 섹션으로 나뉩니다.
  - **Text Section (텍스트 섹션):** 실행 가능한 코드가 포함된 부분입니다[1].
  - **Data Section (데이터 섹션):** 전역 변수가 포함된 부분입니다[1].
  - **Heap Section (힙 섹션):** 프로그램 실행 중 동적으로 할당되는 메모리 공간입니다.
  - **Stack Section (스택 섹션):** 함수 호출 시 사용되는 임시 데이터 저장소로, 함수 매개변수, 반환 주소, 지역 변수가 포함됩니다[1].

- **Process State (프로세스 상태):** 프로세스는 실행 중에 여러 상태로 변할 수 있습니다.
  - **New (새로 생성됨):** 프로세스가 생성 중인 상태입니다[1].
  - **Running (실행 중):** 명령이 실행되고 있는 상태입니다[1].
  - **Waiting (대기 중):** 특정 이벤트(예: I/O 완료)를 기다리는 상태입니다[1].
  - **Ready (준비 완료):** 프로세서 할당을 기다리는 상태입니다[1].
  - **Terminated (종료됨):** 실행이 완료된 상태입니다.

- **PCB (Process Control Block, 프로세스 제어 블록) / TCB (Task Control Block, 태스크 제어 블록):** 각 프로세스는 운영 체제에서 PCB로 표현됩니다. PCB에는 특정 프로세스와 관련된 여러 정보가 포함됩니다:
  - 프로세스 상태
  - 프로그램 카운터
  - CPU 레지스터
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 입출력 상태 정보 등이 포함됩니다.

- **Program Counter (프로그램 카운터):** 다음에 실행될 명령어의 주소를 가리키는 레지스터입니다.

- **CPU Registers (CPU 레지스터):** 현재 수행 중인 작업과 관련된 데이터를 저장하는 프로세서 내의 작은 저장 공간입니다.

- **Thread (쓰레드):** 쓰레드는 경량 프로세스로, 단일 제어 흐름을 가진 프로그램을 의미합니다. 현대 운영 체제에서는 여러 쓰레드를 통해 하나의 프로세스가 동시에 여러 작업을 수행할 수 있도록 확장되었습니다.

## **프로세스 스케줄링 관련 용어**

- **Multiprogramming (다중 프로그래밍):** 여러 프로세스를 메모리에 동시에 유지하여 항상 어떤 프로세스가 실행되도록 하여 CPU 사용률을 최대화하는 기법입니다.

- **Time Sharing (시분할):** CPU 코어를 여러 프로세스 간에 빠르게 전환하여 사용자들이 각 프로그램과 상호작용할 수 있도록 하는 기법입니다.

- **Scheduling Queues (스케줄링 큐):** 
  - **Ready Queue (준비 큐):** 실행 준비가 된 프로세스를 보관하는 큐입니다.
  - **Wait Queue (대기 큐):** 특정 이벤트(예: I/O 완료)를 기다리는 프로세스를 보관하는 큐입니다.
  - 이 큐들은 일반적으로 PCB(프로세스 제어 블록)의 연결 리스트로 구현됩니다.

- **Queueing Diagram (큐잉 다이어그램):** 프로세스 스케줄링의 일반적인 표현 방법으로, 준비 큐와 대기 큐의 상태를 시각적으로 나타냅니다.

- **Context Switch (컨텍스트 스위치):** 현재 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하여 CPU 코어를 다른 프로세스로 전환하는 작업입니다. 이는 인터럽트가 발생할 때 시스템이 실행 중인 프로세스의 현재 컨텍스트를 저장하고 나중에 필요할 때 복원할 수 있도록 합니다.

## **프로세스 연산 관련 용어**

- **Process Creation (프로세스 생성):** 운영 체제는 새로운 프로세스를 생성할 수 있어야 합니다. 새로운 프로세스는 기존 프로세스(부모 프로세스)에 의해 생성되며, 생성된 프로세스를 자식 프로세스라고 합니다. UNIX와 같은 운영 체제에서는 `fork()` 시스템 호출을 통해 새로운 프로세스를 생성합니다. 자식 프로세스는 부모의 주소 공간을 복사하여 시작하며, 이후 `exec()` 시스템 호출을 통해 새로운 프로그램을 실행할 수 있습니다.

- **Process Termination (프로세스 종료):** 프로세스는 마지막 명령을 실행한 후 `exit()` 시스템 호출을 통해 종료됩니다. 이 호출은 운영 체제에 프로세스의 종료를 알리고, 운영 체제는 할당된 메모리와 자원을 회수합니다.

- **Parent and Child Processes (부모 및 자식 프로세스):** 
  - **Parent Process (부모 프로세스):** 새로운 프로세스를 생성하는 기존의 프로세스입니다.
  - **Child Process (자식 프로세스):** 부모 프로세스에 의해 생성된 새로운 프로세스로, 부모의 주소 공간을 복사하여 시작합니다.

- **Zombie Process (좀비 프로세스):** 종료되었지만 부모가 아직 `wait()` 호출을 하지 않아 PCB가 남아 있는 상태의 프로세스입니다.

- **Orphan Process (고아 프로세스):** 부모가 `wait()` 호출 없이 종료된 상태의 자식 프로세스로, 고아가 된 후에는 일반적으로 init 시스템에 의해 처리됩니다.

- **`fork()` System Call:** UNIX 계열 시스템에서 새로운 프로세스를 생성하는 시스템 호출입니다. 이 호출은 현재 실행 중인 프로세스를 복제하여 새로운 자식 프로세스를 만듭니다. `fork()` 호출 후에는 두 개의 실행 흐름이 존재하게 되며, 각각의 흐름은 `fork()` 호출 이후의 코드를 실행합니다.

- **`exec()` System Call:** 자식 프로세스가 다른 프로그램을 실행하도록 하는 시스템 호출입니다. 이 호출은 현재의 프로세스를 완전히 새로운 프로그램으로 대체합니다.

## **프로세스 간 통신 관련 용어**

- **Interprocess Communication (IPC, 프로세스 간 통신):** 서로 다른 프로세스들이 데이터를 교환하고 상호작용할 수 있도록 하는 메커니즘입니다. IPC는 독립적인 프로세스와 협력 프로세스로 나뉘며, 협력 프로세스는 다른 프로세스와 데이터를 공유하거나 영향을 주고받을 수 있습니다.

- **Independent Process (독립 프로세스):** 다른 프로세스와 데이터를 공유하지 않는 프로세스로, 다른 프로세스의 영향을 받지 않습니다.

- **Cooperating Process (협력 프로세스):** 다른 프로세스와 데이터를 공유하거나 상호작용할 수 있는 프로세스로, 다른 프로세스에 의해 영향을 받을 수 있습니다.

- **Shared Memory (공유 메모리):** 여러 프로세스가 메모리의 특정 영역을 공유하여 데이터를 교환하는 방식입니다. 이 방식에서는 응용 프로그램 개발자가 명시적으로 코드를 작성하여 공유 메모리를 접근하고 조작해야 합니다.

- **Message Passing (메시지 전달):** 운영 체제가 제공하는 메시지 전달 기능을 통해 협력하는 프로세스들이 서로 메시지를 주고받는 방식입니다. 메시지 전달은 두 가지 기본 연산으로 구성됩니다:
  - **send(message):** 메시지를 보내는 연산
  - **receive(message):** 메시지를 받는 연산

## **공유 메모리 시스템에서의 프로세스 간 통신 관련 용어**

- **Producer-Consumer Problem (생산자-소비자 문제):** 협력 프로세스를 설명하기 위한 일반적인 패러다임으로, 생산자는 정보를 생성하고 소비자는 그 정보를 소비합니다. 예를 들어, 컴파일러는 어셈블리 코드를 생성하고 어셈블러는 이를 소비합니다. 이 문제는 프로세스 간의 데이터 생산과 소비를 조율하는 데 있어 중요한 개념입니다.

- **Shared Memory (공유 메모리):** 두 개 이상의 프로세스가 메모리의 특정 영역을 공유하여 데이터를 교환하는 방식입니다. 공유 메모리는 생산자와 소비자가 동시에 실행될 수 있도록 하며, 버퍼를 통해 데이터를 주고받습니다.

- **Buffer (버퍼):** 생산자와 소비자가 데이터를 주고받기 위해 사용하는 메모리 공간입니다. 생산자는 버퍼에 데이터를 채우고, 소비자는 버퍼에서 데이터를 가져갑니다.

- **Circular Buffer (순환 버퍼):** 고정된 크기의 버퍼로, 끝에 도달하면 처음으로 돌아가는 방식으로 데이터를 저장합니다. 이는 버퍼의 시작과 끝을 관리하기 위한 `in`과 `out` 포인터를 사용하여 구현됩니다. 이러한 구조는 버퍼가 가득 차거나 비어있을 때 발생할 수 있는 문제를 해결하는 데 유용합니다.

## **메시지 전달 시스템에서의 프로세스 간 통신 관련 용어**

- **Message Passing (메시지 전달):** 운영 체제가 제공하는 기능을 통해 서로 다른 프로세스가 메시지를 주고받으며 통신하는 방식입니다. 이는 공유 메모리 없이 데이터를 교환할 수 있는 방법으로, 특히 분산 시스템에서 유용합니다.

- **Send(message) (메시지 보내기):** 메시지를 다른 프로세스에 전송하는 연산입니다. 이 연산은 메시지 전달 시스템의 기본적인 기능 중 하나입니다.

- **Receive(message) (메시지 받기):** 다른 프로세스로부터 메시지를 수신하는 연산입니다. 메시지 전달 시스템에서 데이터를 수신하기 위한 기본적인 기능입니다.

- **Direct Communication (직접 통신):** 두 프로세스가 서로의 이름을 명시적으로 지정하여 직접 메시지를 주고받는 방식입니다. 이 방식에서는 송신자와 수신자가 서로를 명확히 알아야 합니다.

- **Indirect Communication (간접 통신):** 메시지가 메일박스(또는 포트)를 통해 간접적으로 전달되는 방식입니다. 프로세스들은 서로의 이름을 알 필요 없이 공통의 메일박스를 통해 통신합니다.

- **Communication Link (통신 링크):** 두 프로세스 간에 메시지를 주고받기 위한 경로로, 직접 또는 간접 통신 방식을 통해 구현됩니다.

- **Synchronous Communication (동기식 통신):** 송신자가 메시지를 보내고 수신자가 이를 받을 때까지 기다리는 방식입니다. 이는 양측이 동시에 준비되어 있어야 합니다.

- **Asynchronous Communication (비동기식 통신):** 송신자가 메시지를 보낸 후 즉시 다음 작업을 수행할 수 있는 방식으로, 수신자는 나중에 메시지를 받을 수 있습니다.

- **Blocking and Non-blocking Operations (블로킹 및 논블로킹 연산):**
  - **Blocking Send/Receive:** 송신자나 수신자가 각각 메시지가 전송되거나 수신될 때까지 대기하는 방식입니다.
  - **Non-blocking Send/Receive:** 송신자는 메시지를 보낸 후 즉시 다음 작업을 수행하며, 수신자는 즉시 메시지를 받거나 없음을 확인합니다.

## **IPC 시스템의 예시 관련 용어**

- **POSIX Shared Memory (POSIX 공유 메모리):** POSIX 표준에 따라 구현된 공유 메모리 시스템으로, 메모리 매핑 파일을 사용하여 특정 파일과 공유 메모리 영역을 연관시킵니다. 이는 프로세스 간에 데이터를 공유하기 위한 효율적인 방법입니다.
  - **`shm_open`:** 공유 메모리 객체를 생성하거나 열기 위한 함수입니다.
  - **`ftruncate`:** 공유 메모리 객체의 크기를 설정하는 함수입니다.
  - **`mmap`:** 파일이나 장치의 내용을 메모리에 매핑하는 함수로, 공유 메모리를 사용할 수 있게 합니다.

- **Pipes (파이프):** UNIX 시스템에서 사용되는 초기 IPC 메커니즘 중 하나로, 두 프로세스 간에 데이터를 전달하는 통로 역할을 합니다.
  - **Ordinary Pipes (일반 파이프):** 부모-자식 관계의 프로세스 간에 사용되며, 단방향 통신을 지원합니다.
  - **Named Pipes (명명된 파이프):** 부모-자식 관계 없이도 사용할 수 있으며, 이름을 통해 접근할 수 있는 파이프입니다.

- **Unidirectional Communication (단방향 통신):** 데이터가 한 방향으로만 흐르는 통신 방식으로, 일반 파이프에서 사용됩니다.

- **Bidirectional Communication (양방향 통신):** 데이터가 양방향으로 흐를 수 있는 통신 방식으로, 두 개의 파이프를 사용하여 구현할 수 있습니다.

## **클라이언트-서버 시스템에서의 통신 관련 용어**

- **Socket (소켓):** 네트워크 상에서 두 컴퓨터 간의 통신을 위한 엔드포인트입니다. 소켓은 IP 주소와 포트 번호로 식별되며, TCP/IP 프로토콜을 사용하여 데이터 전송을 관리합니다. 소켓은 연결 지향적(TCP) 또는 비연결 지향적(UDP)으로 설정될 수 있습니다.

- **Connection-Oriented Communication (연결 지향 통신):** 데이터 전송 전에 명시적인 연결 설정이 필요한 통신 방식으로, TCP 프로토콜이 이에 해당합니다. 이 방식은 데이터의 신뢰성과 순서를 보장합니다.

- **Connectionless Communication (비연결 지향 통신):** 데이터 전송 전에 연결 설정이 필요 없는 통신 방식으로, UDP 프로토콜이 이에 해당합니다. 이 방식은 빠른 전송이 가능하지만, 데이터의 신뢰성과 순서는 보장되지 않습니다.

- **Remote Procedure Call (RPC, 원격 프로시저 호출):** 네트워크 상의 다른 시스템에 있는 프로시저를 로컬에서 호출하듯이 실행할 수 있게 하는 메커니즘입니다. RPC는 클라이언트가 원격 서버의 함수를 호출하고 결과를 받는 과정을 추상화하여, 네트워크 통신의 복잡성을 줄입니다.

- **Stub (스텁):** RPC 시스템에서 클라이언트와 서버 사이의 통신을 처리하는 코드 조각입니다. 클라이언트 측 스텁은 서버로 요청을 보내고, 서버 측 스텁은 요청을 받아 실제 프로시저를 실행한 후 결과를 클라이언트로 반환합니다.
